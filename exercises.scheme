#lang racket/base

; Exercise 1.3.  Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.  

(provide sum-of-squares-of-two-larger)

(define (sum-of-squares-of-two-larger-old a b c)
  (cond
    ((and (>= a b) (>= b c)) (+ (* a a) (* b b)))
    ((and (>= a b) (>= c b)) (+ (* a a) (* c c)))
    ((and (>= b a) (>= c a)) (+ (* b b) (* c c)))
    ))

(define (sum-of-squares x1 x2)
  (+ (* x1 x1)
     (* x2 x2)))

(define (sum-square-either x1 x2 x3)
  (cond
    ((> x2 x3)
     (sum-of-squares x1 x2))
    (else (sum-of-squares x1 x3))))

(define (sum-of-squares-of-two-larger x1 x2 x3)
  (cond
    ((or (> x1 x2)
         (> x1 x3))
     (sum-square-either x1 x2 x3))
    (else (sum-of-squares x2 x3))))


(= (sum-of-squares-of-two-larger 2 2 3) 13)

(provide fast-expt)

(define (expt-r b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))

(define (expt b n)
  (expt-iter b n 1))

(define (expt-iter b counter product)
  (if (= counter 0)
      product
      (expt-iter b
                 (- counter 1)
                 (* b product)))) 

(define (square x) (* x x))

(define (fast-expt-r b n)
  (cond ((= n 0) 1)
        ((even? n) (square (fast-expt b (/ n 2))))
        (else (* b (fast-expt b (- n 1))))))

(define (even? n)
  (= (remainder n 2) 0))



 ; Exercise 1.16.  Design a procedure that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does fast-expt.
; (Hint: Using the observation that (b^n/2)^2 = (b^2)^n/2, keep, along with the exponent n and the base b, an additional state variable a, and define the state transformation in such a way that the product a.b^n is unchanged from state to state. At the beginning of the process a is taken to be 1, and the answer is given by the value of a at the end of the process.
; In general, the technique of defining an invariant quantity that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.) 

(define (fast-expt b n) (fast-expt-iter b n))

(define (fast-expt-iter b n)
  (define (iterator accum current)
    (cond
      (= current n) (accum)
      (< (/ n 2) current) (iterator b (square accum) (* 2 current) n)
      (else (iterator b (* b accum) (- current 1) n))))
  (iterator 1 0))



(define (square x) (* x x))

(define (sum-of-squares x y)
  (+ (square x) (square y)))

(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

; To illustrate this process, let's evaluate the combination
(f 5)

; We begin by retrieving the body of f:
(sum-of-squares (+ a 1) (* a 2))

; Then we replace the formal parameter a by the argument 5:
(sum-of-squares (+ 5 1) (* 5 2))

 ; Thus the problem reduces to the evaluation of a combination with two operands and an operator sum-of-squares. Evaluating this combination involves three subproblems. We must evaluate the operator to get the procedure to be applied, and we must evaluate the operands to get the arguments. Now (+ 5 1) produces 6 and (* 5 2) produces 10, so we must apply the sum-of-squares procedure to 6 and 10. These values are substituted for the formal parameters x and y in the body of sum-of-squares, reducing the expression to
(sum-of-squares 6 10)

(+ (square 6) (square 10))

; If we use the definition of square, this reduces to
(+ (* 6 6) (* 10 10))

(+ 36 100)

; normal-order instead:
(f 5)
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))


(define (factorial n)
  (if (= n 1) 1
      (* n (factorial (- n 1)))))

(factorial 6)


(if (= 6 1) 1
  (* 6 (factorial (- 6 1)))))

(if #f 1
  (* 6 (factorial (- 6 1)))))

(* 6 (factorial (- 6 1)))))

(* 6 (factorial 5))))

(* 6 (if (= 5 1) 1
         (* 5 (factorial (- 5 1)))))

(* 6 (* 5 (factorial 4))))
(* 6 (* 5 (

    (if (= 4 1) 1
      (* 4 (factorial (- 4 1)))))
           ))))



 (define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))

(define (factorial n) (fact-iter 1 1 n)


 (fact-iter 1 1 6)

  (fact-iter (* 1 1)
             (+ 1 1)
             6)))

  (fact-iter 1 2 6)))

  (fact-iter 2 3 6))

; Exercise 1.6.  Alyssa P. Hacker doesn't see why (if) needs to be provided as a special form. ``Why can't I just define it as an ordinary procedure in terms of cond?'' she asks. Alyssa's friend Eva Lu Ator claims this can indeed be done, and she defines a new version of if:

